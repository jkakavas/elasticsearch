/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.elasticsearch.ExceptionsHelper;
import org.elasticsearch.bootstrap.Elasticsearch;
import org.elasticsearch.cli.*;
import org.elasticsearch.common.CheckedConsumer;
import org.elasticsearch.common.CheckedFunction;
import org.elasticsearch.common.Randomness;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.network.InetAddresses;
import org.elasticsearch.common.settings.KeyStoreWrapper;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.set.Sets;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.json.JsonXContent;
import org.elasticsearch.env.Environment;
import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;
import org.elasticsearch.xpack.security.authc.esnative.tool.CommandLineHttpClient;
import org.elasticsearch.xpack.security.authc.esnative.tool.HttpResponse;

import javax.security.auth.x500.X500Principal;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.PosixFileAttributeView;
import java.nio.file.attribute.PosixFilePermission;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class EsWrapper extends LoggingAwareMultiCommand {

    private static final String AUTO_GEN_CA_DN = "CN=Elastic Certificate Tool Autogenerated CA";
    private final CheckedFunction<Environment, KeyStoreWrapper, Exception> keyStoreFunction;


    EsWrapper() {
        this(environment -> {
            KeyStoreWrapper keyStoreWrapper = KeyStoreWrapper.load(environment.configFile());
            if (keyStoreWrapper == null) {
                throw new UserException(ExitCodes.CONFIG,
                    "Elasticsearch keystore file is missing [" + KeyStoreWrapper.keystorePath(environment.configFile()) + "]");
            }
            return keyStoreWrapper;
        });
    }
    EsWrapper(CheckedFunction<Environment, KeyStoreWrapper, Exception> keyStoreFunction) {
        super("some description here");
        subcommands.put("init", new ClusterInitCommand());
        subcommands.put("join", new ClusterJoinCommand());
        this.keyStoreFunction = keyStoreFunction;

    }

    public static void main(String[] args) throws Exception {
        exit(new EsWrapper().main(args, Terminal.DEFAULT));
    }

    final class ClusterJoinCommand extends EnvironmentAwareCommand {

        ClusterJoinCommand() {
            super("description");
        }

        @Override protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {

        }
    }

    final class ClusterInitCommand extends EnvironmentAwareCommand {
        private KeyStoreWrapper keyStoreWrapper;
        ClusterInitCommand() {
            super("description");
        }

        @Override protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
            keyStoreWrapper = keyStoreFunction.apply(env);
            keyStoreWrapper.decrypt(new char[0]);
            Settings.Builder settingsBuilder = Settings.builder();
            settingsBuilder.put(env.settings(), true);
            if (settingsBuilder.getSecureSettings() == null) {
                settingsBuilder.setSecureSettings(keyStoreWrapper);
            }
            Settings settings = settingsBuilder.build();

            CommandLineHttpClient httpClient = new CommandLineHttpClient(env);
            //TODO: Check that TLS is not already configured

            final CertificateInformation http = new CertificateInformation(
                new X500Principal("CN=" + getHostname()),
                Collections.singletonList(getIpAddress()),
                Collections.singletonList(getHostname()),
                Collections.emptyList());
            final CAInfo httpCa = generateCA();

            final CertificateInformation transport = new CertificateInformation(
                new X500Principal("CN=" + getHostname()),
                Collections.singletonList(getIpAddress()),
                Collections.singletonList(getHostname()),
                Collections.emptyList());
            final CAInfo transportCa = generateCA();

            generateAndWriteSignedCertificates(Paths.get(env.configFile().toString(), "http.p12").normalize(),
                Collections.singletonList(http), httpCa);
            generateAndWriteSignedCertificates(Paths.get(env.configFile().toString(), "transport.p12").normalize(),
                Collections.singletonList(transport), transportCa);
            updateConfiguration(Paths.get(env.configFile().toString(), "elasticsearch.yml").normalize());
            final SecureString newPassword = generatePassword();
            final SecureString bootstrapPassword = ReservedRealm.BOOTSTRAP_ELASTIC_PASSWORD.get(settings);
            setElasticPassword(terminal, httpClient, bootstrapPassword, newPassword);
            startElasticsearch(env);
            terminal.println("Password for the elastic user: " + password);
            terminal.println("Please copy this password as it will not be shown again.");

        }

        private void setElasticPassword(Terminal terminal, CommandLineHttpClient httpClient, SecureString bootstrapPassword, SecureString newPassword) throws Exception{
            URL route = new URL(httpClient.getDefaultURL(), "/_security/user/elastic/_password", "?pretty");
            try {
                SecureString supplierPassword = newPassword.clone();
                final HttpResponse httpResponse = httpClient.execute("PUT", route, "elastic", bootstrapPassword, () -> {
                    try {
                        XContentBuilder xContentBuilder = JsonXContent.contentBuilder();
                        xContentBuilder.startObject().field("password", supplierPassword.toString()).endObject();
                        return Strings.toString(xContentBuilder);
                    } finally {
                        supplierPassword.close();
                    }
                }, is -> responseBuilder(is, terminal));
                if (httpResponse.getHttpStatus() != HttpURLConnection.HTTP_OK) {
                    terminal.errorPrintln("");
                    terminal.errorPrintln(
                        "Unexpected response code [" + httpResponse.getHttpStatus() + "] from calling PUT " + route.toString());
                    throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to set password for user [\" elastic \"].");
                }
            } catch (IOException e) {
                terminal.errorPrintln("");
                terminal.errorPrintln("Connection failure to: " + route.toString() + " failed: " + e.getMessage());
                throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to set password for user [\" elastic \"].");
            }
        }

        private HttpResponse.HttpResponseBuilder responseBuilder(InputStream is, Terminal terminal) throws IOException {
            HttpResponse.HttpResponseBuilder httpResponseBuilder = new HttpResponse.HttpResponseBuilder();
            if (is != null) {
                byte[] bytes = toByteArray(is);
                String responseBody = new String(bytes, StandardCharsets.UTF_8);
                terminal.println(Terminal.Verbosity.VERBOSE, responseBody);
                httpResponseBuilder.withResponseBody(responseBody);
            } else {
                terminal.println(Terminal.Verbosity.VERBOSE, "<Empty response>");
            }
            return httpResponseBuilder;
        }

        private byte[] toByteArray(InputStream is) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] internalBuffer = new byte[1024];
            int read = is.read(internalBuffer);
            while (read != -1) {
                baos.write(internalBuffer, 0, read);
                read = is.read(internalBuffer);
            }
            return baos.toByteArray();
        }

        private String getHostname() throws Exception {
            return InetAddress.getLocalHost().getCanonicalHostName();
        }

        private String getErrorCause(HttpResponse httpResponse) {
            final Object error = httpResponse.getResponseBody().get("error");
            if (error == null) {
                return null;
            }
            if (error instanceof Map) {
                Object reason = ((Map) error).get("reason");
                if (reason != null) {
                    return reason.toString();
                }
                final Object root = ((Map) error).get("root_cause");
                if (root != null && root instanceof Map) {
                    reason = ((Map) root).get("reason");
                    if (reason != null) {
                        return reason.toString();
                    }
                    final Object type = ((Map) root).get("type");
                    if (type != null) {
                        return (String) type;
                    }
                }
                return String.valueOf(((Map) error).get("type"));
            }
            return error.toString();
        }

        private String getIpAddress() {
            //Resolve multiple interface addresses and add them all?
            return InetAddress.getLoopbackAddress().getHostAddress();
        }

        private CAInfo generateCA() throws Exception {
            X500Principal x500Principal = new X500Principal(AUTO_GEN_CA_DN);
            KeyPair keyPair = CertGenUtils.generateKeyPair(4096);
            X509Certificate caCert = CertGenUtils.generateCACertificate(x500Principal, keyPair, 730);
            return new CAInfo(caCert, keyPair.getPrivate(), true, "password".toCharArray());
        }

        private SecureString generatePassword() {
            final SecureRandom random = Randomness.createSecure();
            final char[] SEED_CHARS = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" + "~!@#$%^&*-_=+?").toCharArray();
            char[] characters = new char[12];
            for (int i = 0; i < 12; ++i) {
                characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)];
            }
            return new SecureString(characters);
        }

        void updateConfiguration(Path configFile) throws Exception{
            List<String> tlsConfiguration = new ArrayList<>();
            tlsConfiguration.add("xpack.security.transport.ssl.enabled: true");
            tlsConfiguration.add("xpack.security.http.ssl.enabled: true");
            tlsConfiguration.add("xpack.security.transport.ssl.verification_mode: certificate");
            tlsConfiguration.add("xpack.security.transport.ssl.keystore.path: transport.p12");
            tlsConfiguration.add("xpack.security.transport.ssl.truststore.path: transport.p12");
            tlsConfiguration.add("xpack.security.http.ssl.keystore.path: http.p12");

            appendLinesToFile(configFile, tlsConfiguration);
        }

        void generateAndWriteSignedCertificates(Path output, Collection<CertificateInformation> certs, CAInfo caInfo) throws Exception {
            assert certs.size() == 1;
            CertificateInformation certificateInformation = certs.iterator().next();
            CertificateAndKey pair = generateCertificateAndKey(certificateInformation, caInfo, 2048, 730);
            fullyWriteFile(output, stream -> writePkcs12(
                stream,
                certificateInformation.name.toString(),
                pair,
                caInfo.certAndKey.cert,
                new char[0]));
        }

        static void writePkcs12(
            OutputStream output,
            String alias,
            CertificateAndKey pair,
            X509Certificate caCert,
            char[] password) throws Exception {
            final KeyStore pkcs12 = KeyStore.getInstance("PKCS12");
            pkcs12.load(null);
            pkcs12.setKeyEntry(alias, pair.key, password, new Certificate[] { pair.cert });
            if (caCert != null) {
                pkcs12.setCertificateEntry("ca", caCert);
            }
            pkcs12.store(output, password);
        }

        private static void fullyWriteFile(Path file, CheckedConsumer<OutputStream, Exception> writer) throws Exception {
            assert file != null;
            assert writer != null;

            boolean success = false;
            if (Files.exists(file)) {
                throw new UserException(ExitCodes.IO_ERROR, "Output file '" + file + "' already exists");
            }
            try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {
                writer.accept(outputStream);

                // set permissions to 600
                PosixFileAttributeView view = Files.getFileAttributeView(file, PosixFileAttributeView.class);
                if (view != null) {
                    view.setPermissions(Sets.newHashSet(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE));
                }

                success = true;
            } finally {
                if (success == false) {
                    Files.deleteIfExists(file);
                }
            }
        }

        private static void appendLinesToFile(Path file, List<String> lines) throws Exception {
            assert file != null;

            if (Files.exists(file) == false) {
                throw new UserException(ExitCodes.IO_ERROR, "Output file '" + file + "' does not exist");
            }
            String output = lines.stream().collect(Collectors.joining(System.lineSeparator()));
            Files.write(file, output.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
        }

        private CertificateAndKey generateCertificateAndKey(
            CertificateInformation certificateInformation, CAInfo caInfo, int keySize, int days) throws Exception {
            KeyPair keyPair = CertGenUtils.generateKeyPair(keySize);
            Certificate certificate = CertGenUtils.generateSignedCertificate(certificateInformation.name,
                getSubjectAlternativeNamesValue(certificateInformation.ipAddresses,
                    certificateInformation.dnsNames,
                    certificateInformation.commonNames),
                keyPair,
                caInfo.certAndKey.cert,
                caInfo.certAndKey.key,
                days);
            return new CertificateAndKey((X509Certificate) certificate, keyPair.getPrivate());
        }
    }

    public static void startElasticsearch(Environment env) throws Exception{
        Runtime.getRuntime().exec("cd "+env.binFile().toAbsolutePath().toString()+" && ./elasticsearch");
    }

    static GeneralNames getSubjectAlternativeNamesValue(List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
        Set<GeneralName> generalNameList = new HashSet<>();
        for (String ip : ipAddresses) {
            generalNameList.add(new GeneralName(GeneralName.iPAddress, ip));
        }

        for (String dns : dnsNames) {
            generalNameList.add(new GeneralName(GeneralName.dNSName, dns));
        }

        for (String cn : commonNames) {
            generalNameList.add(CertGenUtils.createCommonName(cn));
        }

        if (generalNameList.isEmpty()) {
            return null;
        }
        return new GeneralNames(generalNameList.toArray(new GeneralName[0]));
    }

    static class CertificateInformation {
        final X500Principal name;
        final List<String> ipAddresses;
        final List<String> dnsNames;
        final List<String> commonNames;

        CertificateInformation(X500Principal name, List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
            this.name = name;
            this.ipAddresses = ipAddresses == null ? Collections.emptyList() : ipAddresses;
            this.dnsNames = dnsNames == null ? Collections.emptyList() : dnsNames;
            this.commonNames = commonNames == null ? Collections.emptyList() : commonNames;
        }

        List<String> validate() {
            List<String> errors = new ArrayList<>();
            for (String ip : ipAddresses) {
                if (InetAddresses.isInetAddress(ip) == false) {
                    errors.add("[" + ip + "] is not a valid IP address");
                }
            }
            for (String dnsName : dnsNames) {
                if (DERIA5String.isIA5String(dnsName) == false) {
                    errors.add("[" + dnsName + "] is not a valid DNS name");
                }
            }
            return errors;
        }
    }

    static class Name {

        final String originalName;
        final X500Principal x500Principal;
        final String filename;
        final String error;

        private Name(String name, X500Principal x500Principal, String filename, String error) {
            this.originalName = name;
            this.x500Principal = x500Principal;
            this.filename = filename;
            this.error = error;
        }

        @Override public String toString() {
            return getClass().getSimpleName() + "{original=[" + originalName + "] principal=[" + x500Principal + "] file=[" + filename + "] err=[" + error + "]}";
        }
    }

    static class CertificateAndKey {
        final X509Certificate cert;
        final PrivateKey key;

        CertificateAndKey(X509Certificate cert, PrivateKey key) {
            this.cert = cert;
            this.key = key;
        }
    }

    static class CAInfo {
        final CertificateAndKey certAndKey;
        final boolean generated;
        final char[] password;

        CAInfo(X509Certificate caCert, PrivateKey privateKey) {
            this(caCert, privateKey, false, null);
        }

        CAInfo(X509Certificate caCert, PrivateKey privateKey, boolean generated, char[] password) {
            this.certAndKey = new CertificateAndKey(caCert, privateKey);
            this.generated = generated;
            this.password = password;
        }
    }
}
