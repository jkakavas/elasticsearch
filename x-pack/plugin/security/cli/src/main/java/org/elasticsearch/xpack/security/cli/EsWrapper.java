/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
import org.elasticsearch.cli.EnvironmentAwareCommand;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.LoggingAwareMultiCommand;
import org.elasticsearch.cli.Terminal;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.common.CheckedConsumer;
import org.elasticsearch.common.Randomness;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.hash.MessageDigests;
import org.elasticsearch.common.network.InetAddresses;
import org.elasticsearch.common.settings.KeyStoreWrapper;
import org.elasticsearch.common.settings.SecureSetting;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.set.Sets;
import org.elasticsearch.common.xcontent.ToXContent;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.json.JsonXContent;
import org.elasticsearch.env.Environment;

import javax.security.auth.x500.X500Principal;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.PosixFileAttributeView;
import java.nio.file.attribute.PosixFilePermission;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipOutputStream;

public class EsWrapper extends LoggingAwareMultiCommand {

    private static final String AUTO_GEN_CA_DN = "CN=Elastic Certificate Tool Autogenerated CA";

    EsWrapper() {
        super("some description here");
        subcommands.put("init", new ClusterInitCommand());
        subcommands.put("join", new ClusterJoinCommand());

    }

    public static void main(String[] args) throws Exception {
        exit(new EsWrapper().main(args, Terminal.DEFAULT));
    }

    public static void startElasticsearch(Environment env) throws Exception {
        ProcessBuilder builder = new ProcessBuilder();
        builder.inheritIO();
        builder.command(env.binFile().toAbsolutePath().toString() + "/elasticsearch");
        builder.start();
    }

    static GeneralNames getSubjectAlternativeNamesValue(List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
        Set<GeneralName> generalNameList = new HashSet<>();
        for (String ip : ipAddresses) {
            generalNameList.add(new GeneralName(GeneralName.iPAddress, ip));
        }

        for (String dns : dnsNames) {
            generalNameList.add(new GeneralName(GeneralName.dNSName, dns));
        }

        for (String cn : commonNames) {
            generalNameList.add(CertGenUtils.createCommonName(cn));
        }

        if (generalNameList.isEmpty()) {
            return null;
        }
        return new GeneralNames(generalNameList.toArray(new GeneralName[0]));
    }

    static class CertificateInformation {
        final X500Principal name;
        final List<String> ipAddresses;
        final List<String> dnsNames;
        final List<String> commonNames;

        CertificateInformation(X500Principal name, List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
            this.name = name;
            this.ipAddresses = ipAddresses == null ? Collections.emptyList() : ipAddresses;
            this.dnsNames = dnsNames == null ? Collections.emptyList() : dnsNames;
            this.commonNames = commonNames == null ? Collections.emptyList() : commonNames;
        }

        List<String> validate() {
            List<String> errors = new ArrayList<>();
            for (String ip : ipAddresses) {
                if (InetAddresses.isInetAddress(ip) == false) {
                    errors.add("[" + ip + "] is not a valid IP address");
                }
            }
            for (String dnsName : dnsNames) {
                if (DERIA5String.isIA5String(dnsName) == false) {
                    errors.add("[" + dnsName + "] is not a valid DNS name");
                }
            }
            return errors;
        }
    }

    static class Name {

        final String originalName;
        final X500Principal x500Principal;
        final String filename;
        final String error;

        private Name(String name, X500Principal x500Principal, String filename, String error) {
            this.originalName = name;
            this.x500Principal = x500Principal;
            this.filename = filename;
            this.error = error;
        }

        @Override
        public String toString() {
            return getClass().getSimpleName()
                + "{original=["
                + originalName
                + "] principal=["
                + x500Principal
                + "] file=["
                + filename
                + "] err=["
                + error
                + "]}";
        }
    }

    static class CertificateAndKey {
        final X509Certificate cert;
        final PrivateKey key;

        CertificateAndKey(X509Certificate cert, PrivateKey key) {
            this.cert = cert;
            this.key = key;
        }
    }

    static class CAInfo {
        final CertificateAndKey certAndKey;
        final boolean generated;
        final char[] password;

        CAInfo(X509Certificate caCert, PrivateKey privateKey) {
            this(caCert, privateKey, false, null);
        }

        CAInfo(X509Certificate caCert, PrivateKey privateKey, boolean generated, char[] password) {
            this.certAndKey = new CertificateAndKey(caCert, privateKey);
            this.generated = generated;
            this.password = password;
        }
    }

    final class ClusterJoinCommand extends EnvironmentAwareCommand {

        ClusterJoinCommand() {
            super("description");
        }

        @Override
        protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {

        }
    }

    final class ClusterInitCommand extends EnvironmentAwareCommand {

        ClusterInitCommand() {
            super("description");
        }

        @Override
        protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
            // TODO: Check that TLS is not already configured

            final CertificateInformation http = new CertificateInformation(
                new X500Principal("CN=" + getHostname()),
                Collections.singletonList(getIpAddress()),
                Collections.singletonList(getHostname()),
                Collections.emptyList()
            );
            final CAInfo httpCa = generateCA();

            final CertificateInformation transport = new CertificateInformation(
                new X500Principal("CN=" + getHostname()),
                Collections.singletonList(getIpAddress()),
                Collections.singletonList(getHostname()),
                Collections.emptyList()
            );
            final CAInfo transportCa = generateCA();

            generateAndWriteSignedCertificates(
                Paths.get(env.configFile().toString(), "http.p12").normalize(),
                Collections.singletonList(http),
                httpCa
            );
            generateAndWriteSignedCertificates(
                Paths.get(env.configFile().toString(), "transport.p12").normalize(),
                Collections.singletonList(transport),
                transportCa
            );
            final Path configurationFile = Paths.get(env.configFile().toString(), "elasticsearch.yml").normalize();
            Settings settings = Settings.builder()
                .put("xpack.security.enabled", true)
                .put("xpack.security.transport.ssl.enabled", true)
                .put("xpack.security.http.ssl.enabled", true)
                .put("xpack.security.transport.ssl.verification_mode", "certificate")
                .put("xpack.security.transport.ssl.keystore.path", "transport.p12")
                .put("xpack.security.transport.ssl.truststore.path", "transport.p12")
                .put("xpack.security.http.ssl.keystore.path", "http.p12")
                .put(env.settings())
                .build();
            updateConfiguration(configurationFile, settings);
            Environment newEnv = new Environment(settings, env.configFile());
            startElasticsearch(newEnv);
            // TODO: poll to see if its up instead of waiting
            Thread.sleep(15000);
            final SecureString bootstrapPassword = getBootstrapPassword(newEnv);
            final SecureString newPassword = generatePassword();

            CommandLineHttpClient httpClient = new CommandLineHttpClient(newEnv);
            setElasticPassword(terminal, httpClient, bootstrapPassword, newPassword);
            terminal.println("Password for the elastic user: " + newPassword);
            terminal.println("Please copy this password as it will not be shown again.");
            // an API key with permissions to hit only the enrolment API
            String apiKey = generateCredential(terminal, httpClient, newPassword);
            String caCertFingerprint = getCertFingerprint(httpCa.certAndKey.cert);
            final String magic = generateMagicString(apiKey, caCertFingerprint);
            terminal.println("Magic: " + magic);
            terminal.println("Please copy this as it will not be shown again.");
            if (terminal.promptYesNo("Store enrollment bundle for future use?", true)) {
                generateEnrollementBundle(newEnv, httpCa, transportCa);
                terminal.println("Enrollment bundles stored");
            }
        }

        private void generateEnrollementBundle(Environment env, CAInfo httpCa, CAInfo transportCa) throws Exception {
            final Path bundleFile = Paths.get(env.configFile().toAbsolutePath().toString(), "enrollment.p12");

            fullyWriteFile(
                bundleFile,
                outputStream -> writePkcs12(
                    outputStream,
                    Map.of("httpca", httpCa.certAndKey, "transportca", transportCa.certAndKey),
                    null,
                    httpCa.password
                )
            );

        }

        private String getCertFingerprint(X509Certificate cert) throws Exception {
            MessageDigest sha256 = MessageDigests.sha256();
            sha256.update(cert.getEncoded());
            return MessageDigests.toHexString(sha256.digest());
        }

        private String generateMagicString(String apiKey, String fingerprint) throws Exception {
            final String magicStringRaw = apiKey
                + "$"
                + getHostname()
                + "$"
                + getIpAddress()
                + "$"
                + getTransportPort()
                + "$"
                + fingerprint;
            return Base64.getUrlEncoder().encodeToString(magicStringRaw.getBytes(StandardCharsets.UTF_8));
        }

        private String generateCredential(Terminal terminal, CommandLineHttpClient httpClient, SecureString password) throws Exception {
            URL route = new URL(httpClient.getDefaultURL() + "/_security/api_key");
            try (SecureString supplierPassword = password.clone()) {
                final HttpResponse httpResponse = httpClient.execute("PUT", route, "elastic", supplierPassword, () -> {
                    XContentBuilder xContentBuilder = JsonXContent.contentBuilder()
                        .startObject()
                        .field("name", "node_enrollment_key")
                        .startObject("role_descriptors")
                        .startObject("enrollment_role")
                        .array("cluster", "cluster:admin/xpack/enroll")
                        .endObject()
                        .endObject()
                        .endObject();
                    final String body = Strings.toString(xContentBuilder);
                    return body;
                }, is -> responseBuilder(is, terminal));
                if (httpResponse.getHttpStatus() != HttpURLConnection.HTTP_OK) {
                    terminal.errorPrintln("");
                    terminal.errorPrintln(
                        "Unexpected response code [" + httpResponse.getHttpStatus() + "] from calling PUT " + route.toString()
                    );
                    throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to generate enrollment credential.");
                }
                final String apiKey = httpResponse.getResponseBody().get("id") + ":" + httpResponse.getResponseBody().get("api_key");
                return Base64.getUrlEncoder().encodeToString(apiKey.getBytes(StandardCharsets.UTF_8));
            } catch (IOException e) {
                terminal.errorPrintln("");
                terminal.errorPrintln("Connection failure to: " + route.toString() + " failed: " + e.getMessage());
                throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to generate enrollment credential.");
            }
        }

        SecureString getBootstrapPassword(Environment environment) throws Exception {
            KeyStoreWrapper keyStoreWrapper = KeyStoreWrapper.load(environment.configFile());
            keyStoreWrapper.decrypt(new char[0]);
            Settings.Builder settingsBuilder = Settings.builder();
            settingsBuilder.put(environment.settings(), true);
            if (settingsBuilder.getSecureSettings() == null) {
                settingsBuilder.setSecureSettings(keyStoreWrapper);
            }
            Settings settings = settingsBuilder.build();
            final SecureString bootstrapPassword = SecureSetting.secureString("bootstrap.password", KeyStoreWrapper.SEED_SETTING)
                .get(settings);
            return bootstrapPassword;
        }

        private void setElasticPassword(
            Terminal terminal,
            CommandLineHttpClient httpClient,
            SecureString bootstrapPassword,
            SecureString newPassword
        ) throws Exception {
            URL route = new URL(httpClient.getDefaultURL() + "/_security/user/elastic/_password?pretty");
            try {
                SecureString supplierPassword = newPassword.clone();
                final HttpResponse httpResponse = httpClient.execute("PUT", route, "elastic", bootstrapPassword, () -> {
                    try {
                        XContentBuilder xContentBuilder = JsonXContent.contentBuilder();
                        xContentBuilder.startObject().field("password", supplierPassword.toString()).endObject();
                        return Strings.toString(xContentBuilder);
                    } finally {
                        supplierPassword.close();
                    }
                }, is -> responseBuilder(is, terminal));
                if (httpResponse.getHttpStatus() != HttpURLConnection.HTTP_OK) {
                    terminal.errorPrintln("");
                    terminal.errorPrintln(
                        "Unexpected response code [" + httpResponse.getHttpStatus() + "] from calling PUT " + route.toString()
                    );
                    throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to set password for user [\" elastic \"].");
                }
            } catch (IOException e) {
                terminal.errorPrintln("");
                terminal.errorPrintln("Connection failure to: " + route.toString() + " failed: " + e.getMessage());
                throw new UserException(ExitCodes.TEMP_FAILURE, "Failed to set password for user [\" elastic \"].");
            }
        }

        private HttpResponse.HttpResponseBuilder responseBuilder(InputStream is, Terminal terminal) throws IOException {
            HttpResponse.HttpResponseBuilder httpResponseBuilder = new HttpResponse.HttpResponseBuilder();
            if (is != null) {
                byte[] bytes = toByteArray(is);
                String responseBody = new String(bytes, StandardCharsets.UTF_8);
                terminal.println(Terminal.Verbosity.VERBOSE, responseBody);
                httpResponseBuilder.withResponseBody(responseBody);
            } else {
                terminal.println(Terminal.Verbosity.VERBOSE, "<Empty response>");
            }
            return httpResponseBuilder;
        }

        private byte[] toByteArray(InputStream is) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] internalBuffer = new byte[1024];
            int read = is.read(internalBuffer);
            while (read != -1) {
                baos.write(internalBuffer, 0, read);
                read = is.read(internalBuffer);
            }
            return baos.toByteArray();
        }

        private String getHostname() throws Exception {
            return InetAddress.getLocalHost().getCanonicalHostName();
        }

        private String getIpAddress() {
            // Resolve multiple interface addresses and add them all?
            return InetAddress.getLoopbackAddress().getHostAddress();
        }

        private int getTransportPort() {
            // Get this from node info API or the settings?
            return 9300;
        }

        private CAInfo generateCA() throws Exception {
            X500Principal x500Principal = new X500Principal(AUTO_GEN_CA_DN);
            KeyPair keyPair = CertGenUtils.generateKeyPair(4096);
            X509Certificate caCert = CertGenUtils.generateCACertificate(x500Principal, keyPair, 730);
            return new CAInfo(caCert, keyPair.getPrivate(), true, "password".toCharArray());
        }

        private SecureString generatePassword() {
            final SecureRandom random = Randomness.createSecure();
            final char[] SEED_CHARS = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" + "~!@#$%^&*-_=+?").toCharArray();
            char[] characters = new char[12];
            for (int i = 0; i < 12; ++i) {
                characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)];
            }
            return new SecureString(characters);
        }

        void updateConfiguration(Path configFile, Settings settings) throws Exception {
            XContentBuilder yaml = XContentFactory.yamlBuilder();
            yaml.startObject();
            settings.toXContent(yaml, ToXContent.EMPTY_PARAMS);
            yaml.endObject();
            appendConfigToFile(configFile, Strings.toString(yaml));
        }

        void generateAndWriteSignedCertificates(Path output, Collection<CertificateInformation> certs, CAInfo caInfo) throws Exception {
            assert certs.size() == 1;
            CertificateInformation certificateInformation = certs.iterator().next();
            CertificateAndKey pair = generateCertificateAndKey(certificateInformation, caInfo, 2048, 730);
            fullyWriteFile(
                output,
                stream -> writePkcs12(stream, certificateInformation.name.toString(), pair, caInfo.certAndKey.cert, new char[0])
            );
        }

        void writePkcs12(OutputStream output, String alias, CertificateAndKey pair, X509Certificate caCert, char[] password)
            throws Exception {
            writePkcs12(output, Map.of(alias, pair), caCert, password);
        }

        void writePkcs12(OutputStream output, Map<String, CertificateAndKey> aliasKeyCert, X509Certificate caCert, char[] password)
            throws Exception {
            final KeyStore pkcs12 = KeyStore.getInstance("PKCS12");
            pkcs12.load(null);
            for (Map.Entry<String, CertificateAndKey> entry : aliasKeyCert.entrySet()) {
                pkcs12.setKeyEntry(entry.getKey(), entry.getValue().key, password, new Certificate[] { entry.getValue().cert });
            }
            if (caCert != null) {
                pkcs12.setCertificateEntry("ca", caCert);
            }
            pkcs12.store(output, password);
        }

        void fullyWriteFile(Path file, CheckedConsumer<OutputStream, Exception> writer) throws Exception {
            assert file != null;
            assert writer != null;

            boolean success = false;
            if (Files.exists(file)) {
                throw new UserException(ExitCodes.IO_ERROR, "Output file '" + file + "' already exists");
            }
            try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {
                writer.accept(outputStream);

                // set permissions to 600
                PosixFileAttributeView view = Files.getFileAttributeView(file, PosixFileAttributeView.class);
                if (view != null) {
                    view.setPermissions(Sets.newHashSet(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE));
                }

                success = true;
            } finally {
                if (success == false) {
                    Files.deleteIfExists(file);
                }
            }
        }

        void appendConfigToFile(Path file, String config) throws Exception {
            assert file != null;

            if (Files.exists(file) == false) {
                throw new UserException(ExitCodes.IO_ERROR, "Output file '" + file + "' does not exist");
            }
            Files.write(file, config.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
        }

        private CertificateAndKey generateCertificateAndKey(
            CertificateInformation certificateInformation,
            CAInfo caInfo,
            int keySize,
            int days
        ) throws Exception {
            KeyPair keyPair = CertGenUtils.generateKeyPair(keySize);
            Certificate certificate = CertGenUtils.generateSignedCertificate(
                certificateInformation.name,
                getSubjectAlternativeNamesValue(
                    certificateInformation.ipAddresses,
                    certificateInformation.dnsNames,
                    certificateInformation.commonNames
                ),
                keyPair,
                caInfo.certAndKey.cert,
                caInfo.certAndKey.key,
                days
            );
            return new CertificateAndKey((X509Certificate) certificate, keyPair.getPrivate());
        }
    }
}
