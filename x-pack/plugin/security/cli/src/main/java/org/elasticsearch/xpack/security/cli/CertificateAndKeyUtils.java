/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

package org.elasticsearch.xpack.security.cli;

import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.common.CheckedConsumer;
import org.elasticsearch.common.network.InetAddresses;
import org.elasticsearch.common.util.set.Sets;

import javax.security.auth.x500.X500Principal;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.PosixFileAttributeView;
import java.nio.file.attribute.PosixFilePermission;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class CertificateAndKeyUtils {

    static CAInfo generateCA() throws Exception {
        X500Principal x500Principal = new X500Principal("CN=Elasticsearch Autogenerated CA");
        KeyPair keyPair = CertGenUtils.generateKeyPair(4096);
        X509Certificate caCert = CertGenUtils.generateCACertificate(x500Principal, keyPair, 730);
        return new CAInfo(caCert, keyPair.getPrivate(), true, "password".toCharArray());
    }

    static void generateAndWriteSignedCertificates(Path output, Collection<CertificateInformation> certs, CAInfo caInfo) throws Exception {
        assert certs.size() == 1;
        CertificateInformation certificateInformation = certs.iterator().next();
        CertificateAndKey pair = generateCertificateAndKey(certificateInformation, caInfo, 2048, 730);
        fullyWriteFile(output,
            stream -> writePkcs12(stream, certificateInformation.name.toString(), pair, caInfo.certAndKey.cert, new char[0]));
    }

    static void writePkcs12(OutputStream output, String alias, CertificateAndKey pair, X509Certificate caCert, char[] password)
        throws Exception {
        writePkcs12(output, Map.of(alias, pair), caCert, password);
    }

    static void writePkcs12(OutputStream output, Map<String, CertificateAndKey> aliasKeyCert, X509Certificate caCert, char[] password)
        throws Exception {
        final KeyStore pkcs12 = KeyStore.getInstance("PKCS12");
        pkcs12.load(null);
        for (Map.Entry<String, CertificateAndKey> entry : aliasKeyCert.entrySet()) {
            pkcs12.setKeyEntry(entry.getKey(), entry.getValue().key, password, new Certificate[] { entry.getValue().cert });
        }
        if (caCert != null) {
            pkcs12.setCertificateEntry("ca", caCert);
        }
        pkcs12.store(output, password);
    }

    static void fullyWriteFile(Path file, CheckedConsumer<OutputStream, Exception> writer) throws Exception {
        assert file != null;
        assert writer != null;

        boolean success = false;
        if (Files.exists(file)) {
            throw new UserException(ExitCodes.IO_ERROR, "Output file '" + file + "' already exists");
        }
        try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {
            writer.accept(outputStream);

            // set permissions to 600
            PosixFileAttributeView view = Files.getFileAttributeView(file, PosixFileAttributeView.class);
            if (view != null) {
                view.setPermissions(Sets.newHashSet(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE));
            }

            success = true;
        } finally {
            if (success == false) {
                Files.deleteIfExists(file);
            }
        }
    }

    static CertificateAndKey generateCertificateAndKey(
        CertificateInformation certificateInformation, CAInfo caInfo, int keySize, int days) throws Exception {
        KeyPair keyPair = CertGenUtils.generateKeyPair(keySize);
        Certificate certificate = CertGenUtils.generateSignedCertificate(certificateInformation.name,
            getSubjectAlternativeNamesValue(certificateInformation.ipAddresses,
                certificateInformation.dnsNames,
                certificateInformation.commonNames),
            keyPair,
            caInfo.certAndKey.cert,
            caInfo.certAndKey.key,
            days);
        return new CertificateAndKey((X509Certificate) certificate, keyPair.getPrivate());
    }

    static GeneralNames getSubjectAlternativeNamesValue(List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
        Set<GeneralName> generalNameList = new HashSet<>();
        for (String ip : ipAddresses) {
            generalNameList.add(new GeneralName(GeneralName.iPAddress, ip));
        }

        for (String dns : dnsNames) {
            generalNameList.add(new GeneralName(GeneralName.dNSName, dns));
        }

        for (String cn : commonNames) {
            generalNameList.add(CertGenUtils.createCommonName(cn));
        }

        if (generalNameList.isEmpty()) {
            return null;
        }
        return new GeneralNames(generalNameList.toArray(new GeneralName[0]));
    }

    static class CertificateInformation {
        final X500Principal name;
        final List<String> ipAddresses;
        final List<String> dnsNames;
        final List<String> commonNames;

        CertificateInformation(X500Principal name, List<String> ipAddresses, List<String> dnsNames, List<String> commonNames) {
            this.name = name;
            this.ipAddresses = ipAddresses == null ? Collections.emptyList() : ipAddresses;
            this.dnsNames = dnsNames == null ? Collections.emptyList() : dnsNames;
            this.commonNames = commonNames == null ? Collections.emptyList() : commonNames;
        }

        List<String> validate() {
            List<String> errors = new ArrayList<>();
            for (String ip : ipAddresses) {
                if (InetAddresses.isInetAddress(ip) == false) {
                    errors.add("[" + ip + "] is not a valid IP address");
                }
            }
            for (String dnsName : dnsNames) {
                if (DERIA5String.isIA5String(dnsName) == false) {
                    errors.add("[" + dnsName + "] is not a valid DNS name");
                }
            }
            return errors;
        }
    }

    static class Name {

        final String originalName;
        final X500Principal x500Principal;
        final String filename;
        final String error;

        private Name(String name, X500Principal x500Principal, String filename, String error) {
            this.originalName = name;
            this.x500Principal = x500Principal;
            this.filename = filename;
            this.error = error;
        }

        @Override public String toString() {
            return getClass().getSimpleName() + "{original=[" + originalName + "] principal=[" + x500Principal + "] file=[" + filename + "] err=[" + error + "]}";
        }
    }

    static class CertificateAndKey {
        final X509Certificate cert;
        final PrivateKey key;

        CertificateAndKey(X509Certificate cert, PrivateKey key) {
            this.cert = cert;
            this.key = key;
        }
    }

    static class CAInfo {
        final CertificateAndKey certAndKey;
        final boolean generated;
        final char[] password;

        CAInfo(X509Certificate caCert, PrivateKey privateKey) {
            this(caCert, privateKey, false, null);
        }

        CAInfo(X509Certificate caCert, PrivateKey privateKey, boolean generated, char[] password) {
            this.certAndKey = new CertificateAndKey(caCert, privateKey);
            this.generated = generated;
            this.password = password;
        }
    }

    static String getHostname() {
        //implement this;
        return "cecilia";
    }

    static String getIpAddress() {
        return "127.0.0.1";
    }

}
